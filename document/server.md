## node集群
	在单台计算机中提高多核CPU利用率，用一个进程在管理多个子进程来处理http请求。
	多个子进程可以启动同一端口的http服务。

## 分布式
	把一个需要巨大算力的计算任务，拆分成许多小部分，
	然后把这些部分分配给多台计算机进行处理，
	然后把这些计算结果综合起来得到最终结果。

## 容灾
	进程意外退出，如果进行重新启动？

	多进程管理方式，一般可以通过主进程来监控子进程的退出情况，
	主进程发现子进程意外退出后，重新启动子进程。

## 负载均衡
	一个http请求过来，是让进程A处理，还是进程B处理呢？
	怎么保证大家均等的干活呢？

- 早期的负载均衡解决
	像Linux操作系统总是唤醒最近处理任务的进程，因为对于系统来说，上下文切换是很昂贵的操作，
	唤醒最近被唤醒的进程是比较好的选择。早期的这种方式负载是很不均衡的。

- round-robin模式（目前默认的处理方式）
	从0.11.2版本开始cluster开始增加了round-robin模式做负载均衡：
	master进程负责监听，收到请求后转发给worker进程，多个worker进程轮流干活。

- windows下的进程分发
	window采用的是最近唤醒进程优先分发任务，
	所以你会看到你开了多个进程，而只有最近两个进程再处理任务


## 静态资源缓存

* 原理
客户端第一次请求，服务会发送一些字段如下
    Last-Modified 文件最后修改时间
    ETag token值
* 分类
1.强缓存（本地缓存）不与服务器通信
		发生请求时，浏览器会先获取header信息，判断到期日、缓存时效等
		强缓存服务端设置以下两个字段即可，浏览器会自行判断处理
		Cache-Control 缓存时效
		Expires 到期日

2.协商缓存（弱缓存）需与服务器通信
		客户端reqHeader携带If-Modified-Since（最后修改时间）、If-None-Match（token）
		服务器判断两个字段是否与本地文件Last-Modified（最后修改时间）、ETag token（token）
		协商后返回304还是200ok
        
3.chrome浏览器请求状态分析
	from memory cache-> 从内存缓存
		直接从内存中拿到，不会请求服务器，一般已经加载过该资源且缓存在了内存当中，当关闭该页面时，
		此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况
        
	from disk cache-> 从磁盘缓存
		直接从磁盘中拿到，不会请求服务器，也是在已经在之前的某个时间加载过该资源，
		此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中，下次打开仍会from disk cache
    
4.chrome浏览器缓存存放位置
		磁盘-> 非脚本\如css等
		内存-> 脚本、字体、图片

## 登陆
	前端的每一个请求带上token，后端判断token仓库里面，该token是否存在的过程。
	退出登陆，就是把该token移除token仓库的意思。
	这需要前端把token保存在缓存里面，一般是localStorage


## 重定向
	http状态码 301 谨慎使用

	301重定向是永久的重定向，是带有缓存的重定向，
	下一次将不会向后端发送请求，直接跳转缓存的重定向。

	302重定向只是暂时的重定向，比如登陆成功后的重定向，
	浏览器每次都会发送请求。	

## Http Header

	是否允许发送cookie
	res.setHeader('Access-Control-Allow-Credentials','true')

	ajax 发送cookie
	xhr.withCredentials = true;

## 客户端缓存
	- cookie
	每次http请求将发送所有cookie，可设置时间限制，
	cookie中每条cookie的存储空间为4k。

	4kb、安全性小、可加密存储、
	同级路径不能互相获取、上级路径不能获取下级路径

	- localStorge
	永久保存、不会发送到服务器、5mb
	
	- SessionStorage
	关闭浏览器标签页清除数据、临时缓存。
	安全性强